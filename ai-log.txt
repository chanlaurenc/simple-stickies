Commit 2 (Render Notes)
    PROMPT: For Commit 2, I need to temporarily hard-code two notes in mounted() to test v-for and v-model. What is the correct object structure for each note according to the assignment?
    RESPONSE: 
        Each note must be an object with this structure:
        { id: String (or Number), text: String }

        Example:
        this.stickies = [
        { id: 1, text: "Test note 1" },
        { id: 2, text: "Another note" }
        ];
    WHAT I USED/CHANGED: Used the required object structure. Inserted into mounted() for testing.

Commit 3 (Add and delete notes)
    PROMPT: For Commit 3, I need to implement addStickie() and deleteStickie(id). How should I generate a unique id with a fallback if crypto.randomUUID() is not available?
    Why do we need to use filter() with reassignment when deleting in Vue?
    RESPONSE:
        To generate a unique id, use crypto.randomUUID() if it exists. 
        If it is not available, use a fallback such as String(Date.now() + Math.random()).

        Example:
        let id;

        if (crypto && crypto.randomUUID) {
        id = crypto.randomUUID();
        } else {
        id = String(Date.now() + Math.random());
        }

        For deleting:
        Use Array.filter() to return a new array that excludes the matching id.
        Reassign the result back to the array so Vue reactivity detects the change.

        Example:
        this.stickies = this.stickies.filter(s => s.id !== id);
    WHAT I USED/CHANGED: Used the UUID fallback logic and filter + reassignment pattern. Wrote the full addStickie() and deleteStickie() methods and tested adding and deleting multiple notes.

Commit 4 (Add localStorage persistence)
    PROMPT: For Commit 4, I need to implement saveToStorage() and loadFromStorage() for my Vue sticky notes app and add a deep watcher so edits auto-save. What should those methods look like using JSON.stringify / JSON.parse? 
    And how should the watcher + mounted() be set up?
    RESPONSE: 
        Use localStorage.setItem with JSON.stringify to save the stickies array, and localStorage.getItem with JSON.parse to load it back.

        Example:
        saveToStorage() {
            localStorage.setItem(this.storageKey, JSON.stringify(this.stickies));
        }

        loadFromStorage() {
            const stored = localStorage.getItem(this.storageKey);

            if (stored) {
                this.stickies = JSON.parse(stored);
            } else {
                this.stickies = [];
            }
        }

        Call loadFromStorage() in mounted():

        mounted() {
            this.loadFromStorage();
        }

        Add a watcher on stickies with deep: true so changes inside each note (like stickie.text) trigger saving automatically:

        watch: {
            stickies: {
                handler() {
                this.saveToStorage();
                },
                deep: true
            }
        }
    WHAT I USED / CHANGED: Used the JSON.stringify / JSON.parse pattern for persistence and adapted it to use my existing storageKey. 
    Added loadFromStorage() inside mounted() and implemented a deep watcher so editing stickie.text auto-saves. 
    Tested add, edit, delete, and refresh to confirm persistence works correctly.

Commit 5 (Clear all and polish)
    PROMPT: For Commit 5, I need to implement clearAll() in my Vue sticky notes app. It must use confirm("Delete all notes?"), clear the stickies array, and remove the localStorage item using my storageKey. What is the correct way to structure this method?
    RESPONSE:
        Use confirm("Delete all notes?") to ask the user before deleting. 
        If the user confirms, clear the stickies array and remove the localStorage item.

        Example:

        clearAll() {
            const confirmed = confirm("Delete all notes?");

            if (confirmed) {
                this.stickies = [];
                localStorage.removeItem(this.storageKey);
            }
        }
    WHAT I USED/CHANGED: Implemented clearAll() using confirm and removed the item using my existing storageKey. Tested by adding notes, refreshing to confirm persistence, then clearing and refreshing again to confirm storage was removed.